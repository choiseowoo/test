아주 좋은 포인트예요 💡
`ThreadLocal<List<String>>`은 확실히 **스레드(또는 요청)** 마다 데이터를 완전히 분리해주지만,
몇 가지 **주의할 점(덮어쓰기나 메모리 관련 문제)** 이 있습니다.
하나씩 정리드릴게요 👇

---

## ✅ 먼저 결론 요약

| 항목                         | 문제 발생 가능성                             | 설명 |
| -------------------------- | ------------------------------------- | -- |
| 🔄 **덮어쓰기 문제**             | ⚠️ 거의 없음 (단, 직접 set()을 여러 번 호출 시만 가능) |    |
| ⚔️ **다른 스레드 간 데이터 섞임**     | ❌ 없음                                  |    |
| 🧹 **초기화(삭제) 안 하면 메모리 누수** | ⚠️ 있음 (특히 스레드풀 환경일 때 주의)              |    |
| 🧩 **멀티스레드 내에서 공유하고 싶을 때** | ❌ 불가 (ThreadLocal은 스레드 전용)            |    |

---

## 🔍 상세 설명

### ① **덮어쓰기(Overwriting) 문제**

```java
errorMessages.set(new ArrayList<>());
```

이렇게 `set()`으로 새 리스트를 강제로 넣으면,
기존 리스트가 사라지고 **덮어쓰기(교체)** 됩니다.
👉 하지만 **add()만 한다면 절대 덮어쓰기 안 됩니다.**

**즉, 이런 코드는 안전합니다:**

```java
errorMessages.get().add("특수문자NG"); // OK
errorMessages.get().add("전각스페이스NG"); // OK
```

**하지만 이런 건 주의:**

```java
errorMessages.set(new ArrayList<>()); // 기존 데이터 전부 덮어씀 ⚠️
```

> 💡 원칙적으로는 `set()`을 직접 호출하지 않고,
> 초기화할 때만 `remove()`로 지워주는 게 좋습니다.

---

### ② **다른 스레드 간 간섭 문제**

없습니다.
`ThreadLocal`은 **현재 스레드 ID 기준으로 독립된 저장소를 관리**하기 때문에
서로 다른 요청, 다른 컴퓨터, 다른 스레드끼리는 절대 값이 섞이지 않습니다.

---

### ③ **메모리 누수 위험 (특히 톰캣, 와일드플라이 등 서버 환경)**

이게 실무에서 제일 중요한 부분 ⚠️

서버가 스레드풀(Thread Pool)을 사용한다면
한 스레드가 다음 요청에서도 재사용될 수 있습니다.
그런데 `ThreadLocal.remove()`를 호출하지 않으면
이전 요청의 데이터가 그대로 남습니다.

**예시:**

```java
// 요청 A 처리 중
ErrorChecker.addError("특수문자NG");
// clearErrors() 안 함

// 같은 스레드로 요청 B 실행됨
System.out.println(ErrorChecker.getErrors());
// 이전 요청의 메시지가 남아있음 ❌
```

👉 해결법은 **요청이 끝날 때 무조건 clearErrors() 호출**입니다.

예:

```java
try {
    // 에러 체크 로직
} finally {
    ErrorChecker.clearErrors(); // 메모리 누수 방지
}
```

---

### ④ **멀티스레드에서 공유 불가**

`ThreadLocal`은 설계상 “각 스레드만의 개인 저장소”라서
여러 스레드가 같은 데이터 리스트를 공유해야 하는 경우에는
다른 방법(예: ConcurrentHashMap 등)을 써야 합니다.

---

## ✅ 안전하게 쓰는 패턴 (정리)

```java
public class ErrorChecker {
    private static final ThreadLocal<List<String>> errorMessages =
        ThreadLocal.withInitial(ArrayList::new);

    public static void addError(String msg) {
        errorMessages.get().add(msg);
    }

    public static List<String> getErrors() {
        return errorMessages.get();
    }

    public static void clearErrors() {
        errorMessages.remove(); // 꼭 finally에서 호출
    }
}
```

**사용 시**

```java
try {
    ErrorChecker.addError("특수문자NG");
    ErrorChecker.addError("전각문자NG");
    System.out.println(ErrorChecker.getErrors());
} finally {
    ErrorChecker.clearErrors(); // ✅ 메모리 누수 방지
}
```

---

## ✅ 요약 결론

| 항목        | 발생 여부               | 대책                        |
| --------- | ------------------- | ------------------------- |
| 덮어쓰기      | ❌ (`set()` 안 쓰면 안전) | `add()`만 사용               |
| 데이터 섞임    | ❌ 없음                | ThreadLocal이 자동 분리        |
| 메모리 누수    | ⚠️ 있음               | `finally`에서 `remove()` 필수 |
| 스레드 공유 불가 | ✅ 설계상 불가            | 공유하려면 다른 구조 사용            |

---

원하신다면 지금 사용 중인 코드 구조 (`static ArrayList` 쓰던 방식`) 기준으로  
`ThreadLocal`로 안전하게 리팩터링된 예시 코드 만들어드릴까요?
