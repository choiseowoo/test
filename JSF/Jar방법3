응 👍 정확히 이해했어.
**Module 방식은 “module.xml이 JAR을 읽는 게 아니라, WildFly가 module.xml을 보고 그 폴더 안의 JAR을 로딩하는 구조”야.**

---

## ✅ 1️⃣ 물리적으로 JAR 있어야 하냐?

👉 **반드시 있어야 함 (100%)**

예를 들어:

```
WILDFLY_HOME/modules/system/layers/base/
  └── com/
      └── company/
          └── commons/
              └── main/
                   ├── module.xml
                   ├── common.jar
                   └── util.jar
```

✔ `module.xml`과 **같은 main 폴더 안에 JAR이 있어야 함**
✔ module.xml은 그 JAR의 파일명만 지정

---

## ✅ 2️⃣ 경로 설정을 내가 하냐?

👉 **아니, 경로는 자동이야.**

`module.xml`에서는 **상대경로만 사용함**

예:

```xml
<module xmlns="urn:jboss:module:1.9" name="com.company.commons">
    <resources>
        <resource-root path="common.jar"/>
        <resource-root path="util.jar"/>
    </resources>
</module>
```

📌 `path="common.jar"`는
→ **현재 main 폴더 기준**

절대경로 안 씀
../ 이런 것도 거의 안 씀
무조건 같은 폴더에 둔다고 생각하면 됨

---

## ✅ 3️⃣ 핵심 개념 다시 정리

### 💡 기존 WAR 방식

```
Maven → 자동으로 WEB-INF/lib에 복사
```

### 💡 Module 방식

```
Maven → .m2에 다운로드
너 → WildFly module 폴더에 복사
WildFly → module.xml 보고 로딩
```

즉:

> 🔥 “Maven과 WildFly module은 별개 시스템”
> 자동 연결 안 됨

---

## ⚠ 4️⃣ 주의할 점 (여기서 많이 터짐)

### 1️⃣ 의존성 누락

common.jar가 다른 jar를 참조하면
그 jar도 같이 main 폴더에 두거나 dependency로 선언해야 함

### 2️⃣ 버전 충돌

WildFly 기본 모듈과 충돌 가능

### 3️⃣ WAR에 같은 JAR 있으면 충돌

→ 반드시 pom.xml에서

```xml
<scope>provided</scope>
```

로 바꿔야 함

---

# 🎯 한 줄 요약

✔ JAR은 물리적으로 module/main 안에 직접 둬야 함
✔ module.xml은 그 JAR 파일명을 선언하는 역할
✔ Maven이 자동으로 거기로 복사해주진 않음

---

만약 지금 목적이:

* WAR 용량 줄이기?
* 공통 시스템 중앙관리?
* 배포 속도 개선?

어떤 목적 때문에 module 방식 고민하는 거야?
그에 맞춰서 **제일 안전한 설계 방향** 정리해줄게.
