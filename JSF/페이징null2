현재 코드에서 **맨 뒤 이동 버튼을 눌렀을 때 `0` 값을 설정하고 `null`을 리턴해도 DTO가 `null`이 되지 않았던 이유**는 크게 두 가지 가능성이 있어.  

---

## **1️⃣ Java EE (`javax`)와 Jakarta EE (`jakarta`) 차이?**
### **➡️ Java EE와 Jakarta EE의 차이 때문일 가능성은 낮음.**
- Java EE(`javax.*`)에서 Jakarta EE(`jakarta.*`)로 변경되면서 패키지 이름이 바뀌고 몇 가지 사소한 변화는 있지만, **DTO 처리 방식이 달라지지는 않음.**  
- 즉, `null`을 리턴했을 때 DTO가 유지되는 문제는 프레임워크 차이 때문이라기보다는 **어떤 방식으로 DTO가 처리되고 있는지** 확인하는 게 더 중요해.

---

## **2️⃣ AP 송수신 처리(AP 통신) 중 값이 유지된 가능성**
### **➡️ AP 송수신 과정에서 이전 데이터가 유지되었을 가능성이 있음.**
- AP(애플리케이션) 송수신 처리가 어떻게 동작하는지에 따라, **이전 페이지의 DTO 값이 캐싱되었거나 세션에 저장되었을 가능성이 있음.**
- 즉, 버튼을 눌러 `null`을 리턴해도 클라이언트에서 **이전 데이터를 가지고 있어서** DTO가 사라지지 않았을 수 있음.

### **📌 확인해야 할 것**
1. **DTO가 어디에서 생성되고 있는지 확인**
   - AP에서 DTO를 새로 생성하는지, 이전 값을 참조하는지 확인.
   - 예를 들어, **세션 범위(Scoped Bean)에서 DTO를 저장하고 있다면** `null`을 리턴해도 값이 남아 있을 수 있음.

2. **AP 통신 방식 확인**
   - REST API 또는 SOAP 통신을 할 때, 응답 데이터가 캐싱되어서 이전 값이 유지될 가능성 있음.
   - 특히, **클라이언트에서 캐싱된 데이터를 다시 사용하면 null을 리턴해도 이전 값이 남아 있을 수 있음.**

3. **JSF Managed Bean의 범위 확인**
   - `@SessionScoped` Bean을 사용하면, 한 번 저장된 데이터는 세션이 유지되는 동안 계속 남아 있음.
   - `@RequestScoped`이면 매 요청마다 새로운 값이 생성됨.

```java
@ManagedBean
@SessionScoped  // <-- 만약 이렇게 되어 있으면, null을 반환해도 세션에 저장된 값이 남아 있음
public class PageBean {
    private PageDTO pageDTO;
}
```

---

## **📌 결론**
- `javax → jakarta` 변경 때문은 아닐 가능성이 큼.  
- **AP 송수신 과정에서 이전 값이 유지되었거나, 세션/캐싱을 통해 DTO가 남아 있을 가능성이 높음.**  
- DTO 생성 방식과 JSF Bean의 범위를 확인해서, null을 반환했을 때도 이전 값이 남아 있는 이유를 찾아보는 게 중요함.
