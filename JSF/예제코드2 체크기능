ì•„í•˜ ğŸ‘ ìƒí™©ì´ ëª…í™•í•´ì¡Œë„¤ìš”. ì§€ê¸ˆ `ItemValidator`ëŠ” **`ScreenController`ì˜ XML ìºì‹œ â†’ ItemDTO ëª©ë¡ â†’ ì…ë ¥ê°’ ê²€ì‚¬** êµ¬ì¡°ë¼ì„œ, ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì—ì„œëŠ” **FacesContext / ScreenController / UIComponent** ë¥¼ ì „ë¶€ mock ì²˜ë¦¬í•˜ë©´ ë©ë‹ˆë‹¤.

ì•„ë˜ëŠ” JUnit 5 + Mockito ê¸°ë°˜ ì˜ˆì‹œì…ë‹ˆë‹¤.

---

### 1. í…ŒìŠ¤íŠ¸ ì¤€ë¹„

`pom.xml`ì— ë‹¤ìŒ ì˜ì¡´ì„± í•„ìš”:

```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>5.13.0</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.11.0</version>
    <scope>test</scope>
</dependency>
```

---

### 2. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì˜ˆì‹œ

```java
import jakarta.faces.application.Application;
import jakarta.faces.application.FacesMessage;
import jakarta.faces.component.UIComponent;
import jakarta.faces.context.FacesContext;
import jakarta.faces.validator.ValidatorException;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ItemValidatorTest {

    @Test
    void testValidateEnglishValid() {
        // given
        FacesContext context = mock(FacesContext.class);
        Application app = mock(Application.class);
        UIComponent component = mock(UIComponent.class);
        ScreenController controller = mock(ScreenController.class);

        when(context.getApplication()).thenReturn(app);
        when(app.evaluateExpressionGet(eq(context), eq("#{screenController}"), eq(ScreenController.class)))
                .thenReturn(controller);

        // ScreenController mock
        when(controller.getScreenId()).thenReturn("screen1");

        ItemDTO dto = new ItemDTO();
        dto.setId("username");
        dto.setName("ì•„ì´ë””");
        dto.setType("English");
        dto.setLength(10);

        Map<String, List<ItemDTO>> cache = new HashMap<>();
        cache.put("screen1", Collections.singletonList(dto));
        when(controller.getXmlCache()).thenReturn(cache);

        when(component.getId()).thenReturn("username");

        ItemValidator validator = new ItemValidator();

        // when / then
        assertDoesNotThrow(() ->
                validator.validate(context, component, "abcDEF")
        );
    }

    @Test
    void testValidateEnglishInvalid() {
        FacesContext context = mock(FacesContext.class);
        Application app = mock(Application.class);
        UIComponent component = mock(UIComponent.class);
        ScreenController controller = mock(ScreenController.class);

        when(context.getApplication()).thenReturn(app);
        when(app.evaluateExpressionGet(eq(context), eq("#{screenController}"), eq(ScreenController.class)))
                .thenReturn(controller);

        when(controller.getScreenId()).thenReturn("screen1");

        ItemDTO dto = new ItemDTO();
        dto.setId("username");
        dto.setName("ì•„ì´ë””");
        dto.setType("English");
        dto.setLength(10);

        Map<String, List<ItemDTO>> cache = new HashMap<>();
        cache.put("screen1", Collections.singletonList(dto));
        when(controller.getXmlCache()).thenReturn(cache);

        when(component.getId()).thenReturn("username");

        ItemValidator validator = new ItemValidator();

        ValidatorException ex = assertThrows(
                ValidatorException.class,
                () -> validator.validate(context, component, "abc123") // ìˆ«ì ë“¤ì–´ê°€ë©´ ì‹¤íŒ¨
        );

        assertTrue(ex.getFacesMessage().getSummary().contains("ì˜ì–´ë§Œ ì…ë ¥"));
    }

    @Test
    void testValidateOverMaxLength() {
        FacesContext context = mock(FacesContext.class);
        Application app = mock(Application.class);
        UIComponent component = mock(UIComponent.class);
        ScreenController controller = mock(ScreenController.class);

        when(context.getApplication()).thenReturn(app);
        when(app.evaluateExpressionGet(eq(context), eq("#{screenController}"), eq(ScreenController.class)))
                .thenReturn(controller);

        when(controller.getScreenId()).thenReturn("screen1");

        ItemDTO dto = new ItemDTO();
        dto.setId("username");
        dto.setName("ì•„ì´ë””");
        dto.setType("English");
        dto.setLength(5); // ìµœëŒ€ 5ì

        Map<String, List<ItemDTO>> cache = new HashMap<>();
        cache.put("screen1", Collections.singletonList(dto));
        when(controller.getXmlCache()).thenReturn(cache);

        when(component.getId()).thenReturn("username");

        ItemValidator validator = new ItemValidator();

        ValidatorException ex = assertThrows(
                ValidatorException.class,
                () -> validator.validate(context, component, "abcdefgh")
        );

        assertTrue(ex.getFacesMessage().getSummary().contains("ìµœëŒ€ 5ì"));
    }
}
```

---

### 3. í¬ì¸íŠ¸

* `FacesContext.getApplication().evaluateExpressionGet(...)` ë¶€ë¶„ â†’ Mockitoë¡œ `ScreenController` ë°˜í™˜í•˜ë„ë¡ ì„¤ì •
* `ScreenController.getXmlCache()` â†’ ë¯¸ë¦¬ ê°€ì§œ `ItemDTO` ë„£ì–´ë‘ 
* `UIComponent.getId()` â†’ í•„ë“œ ID ì§€ì •
* ê°ê° ì¡°ê±´(`English`, `EnglishAndA`, `ê¸¸ì´ ì´ˆê³¼`)ë³„ë¡œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‘ì„±

---

ğŸ‘‰ í˜¹ì‹œ `ItemDTO` í´ë˜ìŠ¤ êµ¬ì¡° (`id`, `name`, `type`, `length`) ê°€ getter/setter ìˆëŠ” ë‹¨ìˆœ DTO ë§ë‚˜ìš”?
ê·¸ëŸ¼ ìœ„ ì½”ë“œ ê·¸ëŒ€ë¡œ ëŒë ¤ë„ ë  ê±°ì˜ˆìš”.
